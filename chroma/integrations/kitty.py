"""
Creates a color theme for Kitty.

To use this theme, add the following line in your kitty config, where `<path>`
should be replaced with the actual output path of the integration.

```conf
include ./<path>
```

This will make sure to import the theme dynamically, so the entire config file
doesn't have to be modified to change the theme. If other includes exist, then
they might interfere with the themes generated by Chroma.

Note that any present metadata is used by kitty. This shouldn't cause any
significant changes to the behaviour.
"""

from pathlib import Path

import chroma
from chroma.exceptions import ParentDirectoryException
from chroma.integration import Integration
from chroma.logger import Logger
from chroma.utils.theme import validate_header

logger = Logger.get_logger()

KITTY_HEADER = f"# {chroma.CHROMA_GENERATED_HEADER}"


class KittyIntegration(Integration):
    def apply(self):
        colors = self.group.get("colors")
        if colors is None:
            logger.info("Colors for Kitty group is unset. Skipping integration.")
            return

        # TODO: actually support all the themable options in kitty like this:
        # https://github.com/kovidgoyal/kitty-themes/blob/master/template.conf
        theme = {
            "foreground": colors["foreground"],
            "background": colors["background"],
            "color0": colors["black"],
            "color1": colors["red"],
            "color2": colors["green"],
            "color3": colors["yellow"],
            "color4": colors["blue"],
            "color5": colors["magenta"],
            "color6": colors["cyan"],
            "color7": colors["white"],
            "color8": colors["bright_black"],
            "color9": colors["bright_red"],
            "color10": colors["bright_green"],
            "color11": colors["bright_yellow"],
            "color12": colors["bright_blue"],
            "color13": colors["bright_magenta"],
            "color14": colors["bright_cyan"],
            "color15": colors["bright_white"],
        }

        metadata = {
            "name": self.meta.get("name"),
            "author": self.meta.get("author"),
            "blurb": self.meta.get("description"),
        }

        if not validate_header(Path(self.group["out"]), KITTY_HEADER):
            logger.error("Cannot write configuration for Kitty. Skipping integration.")
            return

        generated_file = []
        generated_file.append(KITTY_HEADER)

        # Only write the metadata if the option is set to allow it.
        if self.group.get("write_meta"):
            generated_file.append("# vim:ft=kitty")
            for field, data in metadata.items():
                if data is not None:
                    generated_file.append(f"## {field}: {data}")

        for name, col in theme.items():
            generated_file.append(f"{name} {col}")

        # Manually insert newlines to make it play well with file.writelines()
        generated_file = [line + "\n" for line in generated_file]

        try:
            with open(Path(self.group["out"]).expanduser(), "w") as f:
                f.writelines(generated_file)
        except FileNotFoundError as e:
            ParentDirectoryException(
                f"{e.__str__()}\n"
                "Failed to open file. Does the parent directory exist?"
            )

        logger.info("Successfully applied Kitty theme")


def register():
    return {"kitty": KittyIntegration}
